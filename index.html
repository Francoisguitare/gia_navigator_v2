<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GIA Navigator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Inter', sans-serif;
        background-color: #030712; /* bg-gray-950 */
        color: #f9fafb; /* text-gray-50 */
        overflow-y: scroll;
      }
      .note-dot-blinking {
        animation: pulse-note 1.5s infinite ease-in-out;
      }
      @keyframes pulse-note {
        0%, 100% {
          transform: scale(1);
          opacity: 1;
          filter: drop-shadow(0 0 4px rgba(168, 85, 247, 0.5));
        }
        50% {
          transform: scale(1);
          opacity: 0.8;
          filter: drop-shadow(0 0 10px rgba(168, 85, 247, 0.8));
        }
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.28.0",
    "tone": "https://aistudiocdn.com/tone@^15.1.22",
    "firebase/app": "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js",
    "firebase/auth": "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js",
    "firebase/firestore": "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js",
    "firebase/": "https://aistudiocdn.com/firebase@^12.5.0/"
  }
}
</script>
<!-- Add Babel to transpile JSX/TSX in the browser -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
  <body>
    <div id="root"></div>
    <!-- 
      APPLICATION BUNDLE
      To solve the browser's strict MIME type checking issue, all TypeScript/JSX files
      have been consolidated into this single script block. Babel transpiles this block
      in memory, avoiding any network requests for .ts/.tsx files which were failing.
    -->
    <script type="text/babel" data-type="module">
// Polyfill for 'process' in browser environment
if (typeof process === 'undefined') {
  window.process = {
    env: {
      API_KEY: undefined
    }
  };
}


// === IMPORTS (Libraries) ===
import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import ReactDOM from 'react-dom/client';
import { GoogleGenAI, Type } from "@google/genai";
import { MonoSynth, PolySynth, Synth, MembraneSynth, Part, Transport, Draw, context, start } from 'tone';
import { initializeApp } from "firebase/app";
import { getAuth, onAuthStateChanged, signOut, createUserWithEmailAndPassword, signInWithEmailAndPassword } from "firebase/auth";
import { getFirestore, doc, getDoc, setDoc } from "firebase/firestore";


// === FROM types.ts ===
// Interfaces and Enums are defined here directly
interface TargetNote {
  note: string;
  interval: string;
  intention: string;
  description: string;
  type: 'fondatrice' | 'expressive';
}

interface ChordAnalysis {
  accord: string;
  degre: string;
  front: 'TENSION' | 'RÉSOLUTION' | 'HORS TONALITÉ';
  actionRythmique: 'RAPIDE / AGRESSIF' | 'LENT / LYRIQUE';
  notes: string[];
  allTargetOptions: TargetNote[];
}

interface FullAnalysis {
  tonalite: string;
  notesGamme: string[];
  progressionAnalysis: ChordAnalysis[];
}

interface NotePosition {
  note: string;
  string: number;
  fret: number;
}

interface YoutubeTrack {
    videoId: string;
    title: string;
    url: string;
}

interface GamificationData {
  xp: number;
  level: number;
  timePlayed: number; // in seconds
  firstName?: string;
  recentTracks?: YoutubeTrack[];
}

const PlayerState = {
  Stopped: 'Stopped',
  CountingDown: 'CountingDown',
  Playing: 'Playing',
};


// === FROM constants.ts ===
// App-wide constants are defined here
const NOTES_SHARP = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const NOTES_FLAT = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

const TUNING = ['E', 'A', 'D', 'G', 'B', 'E'];
const TOTAL_CELLS = 24;
const NUM_FRETS = 17;

const GAMIFICATION_XP_PER_LEVEL = 1000;
const GAMIFICATION_XP_PER_SECOND = 2;

const PRESET_PROGRESSIONS = [
    { name: "Pop/Rock Mineur", chords: ['Am', '', 'G', '', 'D', '', 'E', ''] },
    { name: "Jazz ii-V-I (Majeur)", chords: ['Dm7', '', 'G7', '', 'Cmaj7', ''] },
    { name: "Pop/Rock Majeur", chords: ['C', '', 'G', '', 'Am', '', 'F', ''] },
    { name: "Blues 12 Mesures (en A)", chords: ['A7','','A7','','A7','','A7','','D7','','D7','','A7','','A7','','E7','','D7','','A7','','A7',''] }
];


// === FROM services/firebase.ts ===
// Firebase configuration and initialization
const firebaseConfig = {
  apiKey: "AIzaSyBTE9nPP27Pyu0VZ0bF3Hf16d1jsBeumcs",
  authDomain: "gia-navigator.firebaseapp.com",
  projectId: "gia-navigator",
  storageBucket: "gia-navigator.firebasestorage.app",
  messagingSenderId: "684477512379",
  appId: "1:684477512379:web:4f2c8b5ec93510aa74c79e"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);


// === FROM components/icons.tsx ===
// Icon components
const PlayIcon = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
    <path strokeLinecap="round" strokeLinejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

const StopIcon = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

const LoadingSpinner = ({ className }) => (
  <svg className={`animate-spin ${className}`} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
  </svg>
);

const TrophyIcon = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94c.63 1.5 1.98 2.63 3.61 2.96V19H7v2h10v-2h-4v-3.1c1.63-.33 2.98-1.46 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0 -1.1-.9-2-2-2zm-7 6c-1.66 0-3-1.34-3-3V7h6v1c0 1.66-1.34 3-3 3z" />
    </svg>
);

const ClockIcon = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
    </svg>
);

const UserIcon = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
    <path fillRule="evenodd" d="M18.685 19.097A9.723 9.723 0 0021.75 12c0-5.385-4.365-9.75-9.75-9.75S2.25 6.615 2.25 12a9.723 9.723 0 003.065 7.097A9.716 9.716 0 0012 21.75a9.716 9.716 0 006.685-2.653zm-12.54-1.285A7.486 7.486 0 0112 15a7.486 7.486 0 015.855 2.812A8.224 8.224 0 0112 20.25a8.224 8.224 0 01-5.855-2.438zM15.75 9a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" clipRule="evenodd" />
  </svg>
);

const XIcon = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
  </svg>
);

const CheckCircleIcon = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor">
        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
    </svg>
);

const ExclamationTriangleIcon = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor">
        <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.21 3.03-1.742 3.03H4.42c-1.532 0-2.492-1.696-1.742-3.03l5.58-9.92zM10 13a1 1 0 110-2 1 1 0 010 2zm-1-8a1 1 0 011-1h.008a1 1 0 011 1v3.992a1 1 0 01-2 0V5z" clipRule="evenodd" />
    </svg>
);


// === FROM services/geminiService.ts ===
// Gemini API service functions
let ai = null;
let isAiInitialized = false;

const initializeAi = () => {
    if (isAiInitialized) return !!ai;
    const apiKey = process.env.API_KEY;
    if (apiKey) {
        try {
            ai = new GoogleGenAI({ apiKey });
            isAiInitialized = true;
            return true;
        } catch (e) {
            console.error("Error initializing GoogleGenAI, likely missing API Key.", e);
            ai = null;
            isAiInitialized = true;
            return false;
        }
    }
    isAiInitialized = true;
    return false;
};

const analyzeProgressionWithGemini = async (progression) => {
    if (!ai) {
        console.warn("Gemini AI service not initialized (API_KEY missing). Using mock data.");
        return {
            tonalite: "C Majeur (Démo)",
            notesGamme: ["C", "D", "E", "F", "G", "A", "B"],
            progressionAnalysis: progression.filter(c => c).map((c, i) => ({
                accord: c,
                degre: ["I", "V", "vi", "IV"][i % 4],
                notes: [c.charAt(0), "E", "G"],
                front: "RÉSOLUTION",
                actionRythmique: "LENT / LYRIQUE",
                allTargetOptions: [
                    { note: c.charAt(0), interval: "R", intention: "Stabilité", description: "", type: "fondatrice" },
                    { note: "E", interval: "3M", intention: "Couleur", description: "", type: "fondatrice" },
                    { note: "D", interval: "9e", intention: "Lyrisme", description: "", type: "expressive" },
                ]
            }))
        };
    }

    const prompt = `Analyse la progression d'accords suivante pour un guitariste improvisateur: ${progression.join(' ')}.
    1. Détermine la tonalité la plus probable (ex: "C Majeur", "A mineur").
    2. Liste les notes de la gamme correspondante.
    3. Pour chaque accord de la progression (ignore les cases vides), fournis une analyse détaillée.
    - accord: Le nom de l'accord.
    - degre: Le degré de l'accord dans la tonalité (ex: "I", "V7", "vi").
    - notes: La liste des notes qui composent l'accord (ex: ["C", "E", "G"]).
    - front: Classifie l'accord comme "RÉSOLUTION" (stable), "TENSION" (dominant, veut résoudre), ou "HORS TONALITÉ" (inattendu, crée une surprise).
    - actionRythmique: Suggère une approche rythmique: "LENT / LYRIQUE" pour la résolution, "RAPIDE / AGRESSIF" pour la tension.
    - allTargetOptions: Propose des notes cibles pour l'improvisation, en incluant des notes fondatrices (R, 3, 5, 7) et des notes expressives (9, 11, 13, altérations), avec une brève description de leur "intention" (ex: "Stabilité", "Couleur", "Tension Ultime").
    
    Réponds avec un objet JSON valide et rien d'autre. N'ajoute pas de démarqueurs de code comme \`\`\`json.`;

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt
        });

        let jsonText = response.text.trim();
        if (jsonText.startsWith('```json')) {
            jsonText = jsonText.substring(7, jsonText.length - 3).trim();
        }
        const result = JSON.parse(jsonText);
        return result;

    } catch (error) {
        console.error("Error calling Gemini API for progression analysis:", error);
        throw new Error("L'analyse IA a échoué.");
    }
};

const extractChordsFromVideoWithGemini = async (videoTitle) => {
    if (!ai) {
        console.warn("Gemini AI service not initialized (API_KEY missing). Using mock data.");
        // We return an empty array here to indicate failure to the user,
        // rather than confusing them with the same mock chords every time.
        return [];
    }

    const prompt = `Basé sur le titre suivant d'une vidéo YouTube (qui est probablement un backing track), agis comme un musicien expert et extrais la progression d'accords. Titre: "${videoTitle}". Réponds UNIQUEMENT avec la liste des accords séparés par une virgule (par exemple: Am,G,C,F). Ne mets pas d'espaces. Si tu ne trouves pas d'accords clairs, retourne une chaîne vide.`;

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt
        });

        const textResponse = response.text.trim();
        if (textResponse) {
            return textResponse.split(',').filter(c => c);
        }
        return [];

    } catch (error) {
        console.error("Error calling Gemini API for chord extraction:", error);
        throw new Error("L'extraction des accords a échoué.");
    }
};


// === FROM components/GuitarNeck.tsx ===
// GuitarNeck component and helpers
const calculateNotePositions = () => {
  const positions = [];
  const noteIndexMap = {};
  NOTES_SHARP.forEach((n, i) => (noteIndexMap[n] = i));
  NOTES_FLAT.forEach((n, i) => (noteIndexMap[n] = i));

  for (let stringIndex = 0; stringIndex < 6; stringIndex++) {
    const openStringNote = TUNING[5 - stringIndex];
    let currentNoteIndex = noteIndexMap[openStringNote];
    for (let fret = 0; fret <= NUM_FRETS; fret++) {
      const noteName = NOTES_SHARP[currentNoteIndex % 12];
      positions.push({ note: noteName, string: stringIndex, fret });

      const noteNameFlat = NOTES_FLAT[currentNoteIndex % 12];
      if (noteName !== noteNameFlat) {
        positions.push({ note: noteNameFlat, string: stringIndex, fret });
      }
      currentNoteIndex++;
    }
  }
  return positions;
};

const notePositions = calculateNotePositions();

const GuitarNeck = ({ highlightedNotes, scaleNotes = [] }) => {
  const neckRef = React.useRef(null);
  const [isMounted, setIsMounted] = useState(false);

  useEffect(() => {
    setIsMounted(true);
  }, []);

  const neckDimensions = {
    height: 140,
    nutWidth: 40,
    getNeckWidth: () => (neckRef.current?.clientWidth ?? 800) - 40,
  };

  const getNoteCoordinates = (string, fret) => {
    const y = (neckDimensions.height / 12) * (string * 2 + 1);
    const x =
      fret === 0
        ? neckDimensions.nutWidth / 2
        : neckDimensions.nutWidth + ((fret - 0.5) * (neckDimensions.getNeckWidth() / NUM_FRETS));
    return { x, y };
  };

  const scaleNoteElements = useMemo(() => {
    if (!Array.isArray(scaleNotes)) return [];
    return scaleNotes.flatMap(note =>
      notePositions
        .filter(p => p.note === note && p.fret > 0)
        .map(p => {
          const { x, y } = getNoteCoordinates(p.string, p.fret);
          return <circle key={`${note}-${p.string}-${p.fret}`} cx={x} cy={y} r={10} fill="none" stroke="#4b5563" strokeWidth="1.5" opacity="0.4" />;
        })
    );
  }, [scaleNotes]);

  const highlightedNoteElements = useMemo(() => {
    if (!Array.isArray(highlightedNotes)) return [];
    return highlightedNotes.flatMap(hNote =>
      notePositions
        .filter(p => p.note === hNote.note && p.fret > 0)
        .map(p => {
          const { x, y } = getNoteCoordinates(p.string, p.fret);
          return (
            <g key={`${hNote.note}-${p.string}-${p.fret}`}>
              <circle
                cx={x}
                cy={y}
                r={10}
                fill={hNote.color}
                stroke="#030712"
                strokeWidth={2}
                className={`transition-all duration-200 ${hNote.isBlinking ? 'note-dot-blinking' : ''}`}
              />
              <text x={x} y={y} dy="0.35em" textAnchor="middle" fontSize="10" fontWeight="bold" fill="#030712" className="pointer-events-none">
                {hNote.label ?? hNote.note}
              </text>
            </g>
          );
        })
    );
  }, [highlightedNotes]);


  return (
    <div className="w-full overflow-x-auto bg-gray-900 p-2 rounded-lg">
      <svg ref={neckRef} width="100%" height={neckDimensions.height + 20} className="min-w-[800px]">
        <rect x="0" y="0" width="100%" height={neckDimensions.height} fill="#1f2937" rx="8" />
        
        <g id="scale-notes">{scaleNoteElements}</g>

        {/* Frets and Strings */}
        {Array.from({ length: 6 }).map((_, i) => (
          <line
            key={`string-${i}`}
            x1={neckDimensions.nutWidth}
            y1={(neckDimensions.height / 12) * (i * 2 + 1)}
            x2="100%"
            y2={(neckDimensions.height / 12) * (i * 2 + 1)}
            stroke="#4b5563"
            strokeWidth={1 + (i * 0.2)}
          />
        ))}
        {Array.from({ length: NUM_FRETS + 1 }).map((_, i) => (
          <line
            key={`fret-${i}`}
            x1={neckDimensions.nutWidth + (i * (neckDimensions.getNeckWidth() / NUM_FRETS))}
            y1={(neckDimensions.height / 12)}
            x2={neckDimensions.nutWidth + (i * (neckDimensions.getNeckWidth() / NUM_FRETS))}
            y2={(neckDimensions.height / 12) * 11}
            stroke={i === 0 ? '#d1d5db' : '#6b7280'}
            strokeWidth={i === 0 ? 5 : 2}
          />
        ))}
        
        {/* Fret Markers */}
        {[3, 5, 7, 9, 15, 17].map(fret => (
            <circle key={`marker-${fret}`} cx={neckDimensions.nutWidth + ((fret - 0.5) * (neckDimensions.getNeckWidth() / NUM_FRETS))} cy={neckDimensions.height / 2} r={5} fill="#4b5563" />
        ))}
        <circle cx={neckDimensions.nutWidth + ((12 - 0.5) * (neckDimensions.getNeckWidth() / NUM_FRETS))} cy={neckDimensions.height / 3} r={5} fill="#4b5563" />
        <circle cx={neckDimensions.nutWidth + ((12 - 0.5) * (neckDimensions.getNeckWidth() / NUM_FRETS))} cy={2 * neckDimensions.height / 3} r={5} fill="#4b5563" />
        
        {/* Fret Numbers */}
        {[3, 5, 7, 9, 12, 15, 17].map(fret => (
            <text key={`fret-num-${fret}`} x={neckDimensions.nutWidth + ((fret - 0.5) * (neckDimensions.getNeckWidth() / NUM_FRETS))} y={neckDimensions.height + 15} textAnchor="middle" fontSize="10" fill="#9ca3af">{fret}</text>
        ))}

        <g id="highlighted-notes">{highlightedNoteElements}</g>
      </svg>
    </div>
  );
};


// === FROM components/AuthModal.tsx ===
// AuthModal component
const AuthModal = ({ isOpen, onClose, initialGamificationData }) => {
  const [activeTab, setActiveTab] = useState('login');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [firstName, setFirstName] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!isOpen) {
      setEmail('');
      setPassword('');
      setFirstName('');
      setError(null);
      setIsLoading(false);
      setActiveTab('login');
    }
  }, [isOpen]);

  const getFirebaseErrorMessage = (errorCode) => {
    switch (errorCode) {
      case 'auth/invalid-email':
        return 'Adresse email invalide.';
      case 'auth/user-not-found':
      case 'auth/wrong-password':
      case 'auth/invalid-credential':
        return 'Email ou mot de passe incorrect.';
      case 'auth/email-already-in-use':
        return 'Cette adresse email est déjà utilisée.';
      case 'auth/weak-password':
        return 'Le mot de passe doit contenir au moins 6 caractères.';
      case 'auth/operation-not-allowed':
        return "Erreur de configuration : La connexion par Email/Mot de passe n'est pas activée. (Note pour le développeur : veuillez l'activer dans votre console Firebase -> Authentication -> Sign-in method).";
      default:
        return 'Une erreur est survenue. Veuillez réessayer.';
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    try {
      if (activeTab === 'login') {
        await signInWithEmailAndPassword(auth, email, password);
      } else {
        if (!firstName.trim()) {
            setError("Veuillez entrer votre prénom.");
            setIsLoading(false);
            return;
        }
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        const userData = {
            ...initialGamificationData,
            firstName: firstName.trim(),
        };
        await setDoc(doc(db, "users", userCredential.user.uid), userData);
      }
      onClose();
    } catch (err) {
      console.error("Firebase Auth Error:", err, err.code);
      setError(getFirebaseErrorMessage(err.code));
    } finally {
      setIsLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4" onClick={onClose}>
      <div className="w-full max-w-sm bg-gray-900 rounded-2xl border border-gray-700 shadow-2xl shadow-purple-500/10 p-8" onClick={e => e.stopPropagation()}>
        <div className="flex justify-end">
             <button onClick={onClose} className="text-gray-500 hover:text-white transition-colors">
                <XIcon className="w-6 h-6"/>
            </button>
        </div>
        
        <div className="mb-6">
          <div className="flex border-b border-gray-700">
            <button
              onClick={() => setActiveTab('login')}
              className={`w-1/2 py-3 text-sm font-bold transition-colors ${activeTab === 'login' ? 'text-purple-400 border-b-2 border-purple-400' : 'text-gray-400 hover:text-white'}`}
            >
              CONNEXION
            </button>
            <button
              onClick={() => setActiveTab('signup')}
              className={`w-1/2 py-3 text-sm font-bold transition-colors ${activeTab === 'signup' ? 'text-purple-400 border-b-2 border-purple-400' : 'text-gray-400 hover:text-white'}`}
            >
              INSCRIPTION
            </button>
          </div>
        </div>

        <form onSubmit={handleSubmit}>
          <div className="space-y-4">
            {activeTab === 'signup' && (
                <div>
                    <label htmlFor="firstName" className="block text-sm font-medium text-gray-400 mb-2">Prénom</label>
                    <input
                        type="text"
                        id="firstName"
                        value={firstName}
                        onChange={e => setFirstName(e.target.value)}
                        required
                        className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500"
                        placeholder="Alex"
                    />
                </div>
            )}
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-400 mb-2">Email</label>
              <input
                type="email"
                id="email"
                value={email}
                onChange={e => setEmail(e.target.value)}
                required
                className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500"
                placeholder="vous@email.com"
              />
            </div>
            <div>
              <label htmlFor="password"className="block text-sm font-medium text-gray-400 mb-2">Mot de passe</label>
              <input
                type="password"
                id="password"
                value={password}
                onChange={e => setPassword(e.target.value)}
                required
                className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500"
                placeholder="********"
              />
            </div>
          </div>
          
          {error && <p className="text-red-400 text-sm mt-4 text-center">{error}</p>}

          <button
            type="submit"
            disabled={isLoading}
            className="w-full mt-6 py-3 px-4 bg-purple-600 hover:bg-purple-500 rounded-lg font-semibold text-white transition-all duration-200 flex items-center justify-center disabled:bg-gray-600 disabled:cursor-not-allowed"
          >
            {isLoading ? <LoadingSpinner className="w-5 h-5"/> : (activeTab === 'login' ? 'Se connecter' : "S'inscrire")}
          </button>
        </form>
      </div>
    </div>
  );
};


// === FROM App.tsx ===
// Main application component and its sub-components
const YoutubePlayer = ({ onPlaybackChange, onTrackLoaded, recentTracks = [], onAnalyzeVideo, isAnalyzingVideo, isAiAvailable }) => {
    const [urlInput, setUrlInput] = useState('');
    const [videoId, setVideoId] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const playerRef = useRef(null);
    const playerContainerRef = useRef(null);

    const fetchVideoTitle = async (id) => {
        try {
            const response = await fetch(`https://noembed.com/embed?url=https://www.youtube.com/watch?v=${id}`);
            if (!response.ok) throw new Error('Failed to fetch video title');
            const data = await response.json();
            return data.title || 'Titre inconnu';
        } catch (error) {
            console.error(error);
            return 'Titre inconnu';
        }
    };

    const onPlayerStateChange = (event) => {
        if (event.data === 1) { // 1 is YT.PlayerState.PLAYING
            onPlaybackChange(true);
        } else if (event.data === 2 || event.data === 0) { // 2 is PAUSED, 0 is ENDED
            onPlaybackChange(false);
        }
    };

    useEffect(() => {
        const createPlayer = () => {
            if (playerContainerRef.current && !playerRef.current) {
                playerRef.current = new window.YT.Player(playerContainerRef.current.id, {
                    height: '100%',
                    width: '100%',
                    videoId: videoId,
                    playerVars: { 'playsinline': 1 },
                    events: {
                        'onStateChange': onPlayerStateChange
                    }
                });
            }
        };

        if (videoId) {
            if (!window.YT || !window.YT.Player) {
                window.onYouTubeIframeAPIReady = createPlayer;
                if (!document.querySelector('script[src="https://www.youtube.com/iframe_api"]')) {
                    const tag = document.createElement('script');
                    tag.src = "https://www.youtube.com/iframe_api";
                    document.body.appendChild(tag);
                }
            } else {
                createPlayer();
            }
        }

        return () => {
            if (playerRef.current) {
                playerRef.current.destroy();
                playerRef.current = null;
            }
            if(window.onYouTubeIframeAPIReady) {
                window.onYouTubeIframeAPIReady = null;
            }
        };
    }, [videoId]);

    const handleLoadVideo = async (urlToLoad) => {
        const url = urlToLoad || urlInput;
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(youtubeRegex);
        const newVideoId = match ? match[1] : null;

        if (newVideoId !== videoId) {
             setVideoId(newVideoId);
        }

        if (newVideoId) {
            setIsLoading(true);
            const title = await fetchVideoTitle(newVideoId);
            onTrackLoaded({ videoId: newVideoId, title, url });
            setIsLoading(false);
        } else {
            onPlaybackChange(false);
        }
    };
    
    const handleClear = () => {
        setUrlInput('');
        setVideoId(null);
        onPlaybackChange(false);
    }

    const handleRecentClick = (track) => {
        setUrlInput(track.url);
        handleLoadVideo(track.url);
    };

    return (
        <div className="flex flex-col gap-3">
             <div className="flex flex-col sm:flex-row gap-2">
                <input
                    type="text"
                    value={urlInput}
                    onChange={e => setUrlInput(e.target.value)}
                    placeholder="Collez une URL YouTube ici..."
                    className="w-full p-2 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500"
                />
                <div className="flex gap-2">
                    <button onClick={() => handleLoadVideo()} disabled={isLoading || isAnalyzingVideo} className="w-full sm:w-auto flex-1 bg-purple-600 hover:bg-purple-500 text-white font-semibold py-2 px-4 rounded-lg transition disabled:bg-gray-600 flex items-center justify-center">
                        {isLoading ? <LoadingSpinner className="w-5 h-5"/> : 'Charger'}
                    </button>
                    {videoId && <button onClick={onAnalyzeVideo} disabled={isAnalyzingVideo || isLoading || !isAiAvailable} className="w-full sm:w-auto flex-1 bg-blue-600 hover:bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg transition disabled:bg-gray-600 disabled:cursor-not-allowed flex items-center justify-center" title={!isAiAvailable ? "Fonctionnalité IA non disponible" : "Analyser la vidéo"}>
                        {isAnalyzingVideo ? <LoadingSpinner className="w-5 h-5"/> : 'Analyser'}
                    </button>}
                    {videoId && <button onClick={handleClear} className="bg-red-800/50 hover:bg-red-700 text-white font-semibold py-2 px-3 rounded-lg transition">Vider</button>}
                </div>
            </div>
             {Array.isArray(recentTracks) && recentTracks.length > 0 && (
                <div className="flex flex-wrap gap-2 pt-2 border-t border-gray-800">
                    <span className="text-xs font-semibold text-gray-400 self-center">Récents:</span>
                    {recentTracks.map(track => (
                        <button
                            key={track.videoId}
                            onClick={() => handleRecentClick(track)}
                            className="text-xs bg-gray-700 hover:bg-gray-600 text-gray-200 py-1 px-2 rounded-md transition"
                            title={track.title}
                        >
                            {track.title.length > 30 ? `${track.title.substring(0, 27)}...` : track.title}
                        </button>
                    ))}
                </div>
            )}
            {videoId && (
                <div className="aspect-video w-full max-w-2xl mx-auto rounded-lg overflow-hidden border-2 border-gray-700 mt-2">
                    <div id="yt-player-container" ref={playerContainerRef}></div>
                </div>
            )}
        </div>
    );
};

const CircleProgress = ({ progress, size, strokeWidth, level }) => {
    const center = size / 2;
    const radius = center - strokeWidth / 2;
    const circumference = 2 * Math.PI * radius;
    const offset = circumference - (progress / 100) * circumference;

    return (
        <div className="relative" style={{ width: size, height: size }}>
            <svg width={size} height={size} className="-rotate-90">
                <circle stroke="#374151" fill="transparent" strokeWidth={strokeWidth} r={radius} cx={center} cy={center} />
                <circle
                    stroke="#facc15"
                    fill="transparent"
                    strokeWidth={strokeWidth}
                    strokeDasharray={circumference}
                    strokeDashoffset={offset}
                    r={radius}
                    cx={center}
                    cy={center}
                    strokeLinecap="round"
                    className="transition-all duration-300 ease-linear"
                />
            </svg>
            <div className="absolute inset-0 flex flex-col items-center justify-center">
                <span className="text-xs font-semibold text-yellow-500">LVL</span>
                <span className="text-xl font-bold text-white">{level}</span>
            </div>
        </div>
    );
};

const GamificationDashboard = ({ data }) => {
    const levelProgress = (data.xp / GAMIFICATION_XP_PER_LEVEL) * 100;
    return (
        <div className="fixed bottom-0 left-0 right-0 bg-gray-950/80 backdrop-blur-sm border-t border-gray-800 p-3 z-30">
            <div className="w-full max-w-7xl mx-auto flex items-center justify-between gap-4 text-sm sm:justify-around">
                <div className="flex items-center gap-4">
                     <CircleProgress progress={levelProgress} size={50} strokeWidth={5} level={data.level} />
                     <div className="flex flex-col">
                        <span className="font-bold text-lg text-white">Niveau {data.level}</span>
                        <span className="text-xs text-gray-400">{data.xp} / {GAMIFICATION_XP_PER_LEVEL} XP</span>
                     </div>
                </div>
                <div className="flex flex-col items-center gap-1 text-cyan-400">
                     <ClockIcon className="w-6 h-6"/>
                     <span className="font-semibold text-sm">{Math.floor(data.timePlayed / 60)}m {data.timePlayed % 60}s</span>
                     <span className="text-xs text-gray-400">Temps de jeu</span>
                </div>
            </div>
        </div>
    );
};

const AnalysisCard = ({ analysis, analysisIndex, onSelectNote, selectedNote }) => {
    if (!analysis) return null;
    const frontStyles = {
        'RÉSOLUTION': 'border-blue-500/50 bg-blue-500/10',
        'TENSION': 'border-red-500/50 bg-red-500/10',
        'HORS TONALITÉ': 'border-yellow-500/50 bg-yellow-500/10'
    };
    
    const badgeStyles = {
        'RÉSOLUTION': 'bg-blue-500 text-blue-50',
        'TENSION': 'bg-red-500 text-red-50',
        'HORS TONALITÉ': 'bg-yellow-500 text-yellow-50'
    };
    
    return (
        <div className={`p-1 w-full sm:w-1/2 md:w-1/3 lg:w-1/4`}>
            <div className={`h-full rounded-lg border-2 p-3 flex flex-col space-y-3 ${frontStyles[analysis.front]}`}>
                <div className="flex justify-between items-start">
                    <h3 className="text-xl font-extrabold text-white">{analysis.accord} <span className="text-base font-semibold text-gray-400">{analysis.degre}</span></h3>
                    <span className={`px-2 py-0.5 text-xs font-semibold rounded-full ${badgeStyles[analysis.front]}`}>{analysis.front}</span>
                </div>
                <p className="text-xs font-semibold text-gray-400">{analysis.actionRythmique}</p>
                
                <div>
                    <p className="text-xs font-bold tracking-wider text-purple-400 mb-2">NOTE CIBLE</p>
                    <div className="space-y-1.5">
                        {analysis.allTargetOptions && analysis.allTargetOptions.map((item, index) => {
                            const isSelected = selectedNote?.note === item.note && selectedNote?.interval === item.interval;
                            return (
                                <button
                                    key={index}
                                    onClick={() => onSelectNote(item)}
                                    className={`w-full text-left p-2 rounded-md text-sm transition-all duration-200 ${
                                        isSelected
                                            ? 'bg-purple-500 text-white shadow-lg'
                                            : 'bg-gray-700/50 hover:bg-gray-600/50'
                                    }`}
                                >
                                    <span className="font-bold">{item.note} ({item.interval})</span> - <span className="text-gray-300">{item.intention}</span>
                                </button>
                            );
                        })}
                    </div>
                </div>
            </div>
        </div>
    );
};

const SaveStatusIndicator = ({ status }) => {
    const statusMap = {
        saving: {
            icon: <LoadingSpinner className="w-4 h-4 text-gray-400" />,
            title: "Sauvegarde en cours...",
        },
        saved: {
            icon: <CheckCircleIcon className="w-4 h-4 text-green-400" />,
            title: "Sauvegardé",
        },
        error: {
            icon: <ExclamationTriangleIcon className="w-4 h-4 text-red-400" />,
            title: "Erreur de sauvegarde",
        },
    };

    if (!status || status === 'idle') return null;

    const currentStatus = statusMap[status];

    return (
        <div title={currentStatus.title} className="flex items-center">
            {currentStatus.icon}
        </div>
    );
};

const INITIAL_GAMIFICATION_DATA = { xp: 0, level: 1, timePlayed: 0, recentTracks: [] };

function App() {
    const [chords, setChords] = useState(Array(TOTAL_CELLS).fill(''));
    const [analysis, setAnalysis] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const [selectedNotes, setSelectedNotes] = useState({});

    const [playerState, setPlayerState] = useState(PlayerState.Stopped);
    const [currentBeat, setCurrentBeat] = useState(-1);
    const [tempo, setTempo] = useState(60);
    const [volumes, setVolumes] = useState({ metro: -12, bass: -6, chord: -14 });
    const [isYoutubePlaying, setIsYoutubePlaying] = useState(false);
    
    const [gamificationData, setGamificationData] = useState(INITIAL_GAMIFICATION_DATA);
    const gamificationDataRef = useRef(INITIAL_GAMIFICATION_DATA);
    
    const [currentUser, setCurrentUser] = useState(null);
    const [isAuthModalOpen, setIsAuthModalOpen] = useState(false);
    const [saveStatus, setSaveStatus] = useState('idle');
    
    const [currentTrack, setCurrentTrack] = useState(null);
    const [isAnalyzingVideo, setIsAnalyzingVideo] = useState(false);
    
    const [isAiAvailable, setIsAiAvailable] = useState(false);
    
    const isSavingRef = useRef(false);
    const synths = useRef({}).current;
    const transportPart = useRef(null);
    const countdownPart = useRef(null);
    const debouncedAnalysis = useRef(null);
    
    useEffect(() => {
        setIsAiAvailable(initializeAi());
    }, []);
    
    const updateGamificationData = useCallback((updater) => {
        const newValue = typeof updater === 'function' ? updater(gamificationDataRef.current) : updater;
        gamificationDataRef.current = newValue;
        setGamificationData(newValue);
    }, []);

    const saveUserData = useCallback(async () => {
        if (!currentUser || isSavingRef.current) return;
        isSavingRef.current = true;
        setSaveStatus('saving');
        const dataToSave = gamificationDataRef.current;
        const saveDataPromise = setDoc(doc(db, 'users', currentUser.uid), dataToSave, { merge: true });
        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 8000));

        try {
            await Promise.race([saveDataPromise, timeoutPromise]);
            setSaveStatus('saved');
            setTimeout(() => setSaveStatus(current => (current === 'saved' ? 'idle' : current)), 2000);
        } catch (error) {
            console.error("Save Error:", error);
            setSaveStatus('error');
            setTimeout(() => setSaveStatus(current => (current === 'error' ? 'idle' : current)), 5000);
        } finally {
            isSavingRef.current = false;
        }
    }, [currentUser]);

    useEffect(() => {
        const unsubscribe = onAuthStateChanged(auth, async (user) => {
            if (user) {
                setCurrentUser(user);
                const userDocRef = doc(db, 'users', user.uid);
                const userDoc = await getDoc(userDocRef);
                if (userDoc.exists()) {
                    const data = userDoc.data();
                    if (!data.recentTracks) data.recentTracks = [];
                    updateGamificationData(data);
                } else {
                    await setDoc(doc(db, "users", user.uid), INITIAL_GAMIFICATION_DATA);
                    updateGamificationData(INITIAL_GAMIFICATION_DATA);
                }
            } else {
                setCurrentUser(null);
                updateGamificationData(INITIAL_GAMIFICATION_DATA);
            }
        });
        return () => unsubscribe();
    }, [updateGamificationData]);
    
    useEffect(() => {
        if (!currentUser) return;
        const saveInterval = setInterval(() => {
            if (!isSavingRef.current) saveUserData();
        }, 3000);
        return () => clearInterval(saveInterval);
    }, [currentUser, saveUserData]);

    useEffect(() => {
        const handleVisibilityChange = () => {
            if (document.visibilityState === 'hidden' && currentUser && !isSavingRef.current) saveUserData();
        };
        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
    }, [currentUser, saveUserData]);

    const handleChordChange = (index, value) => {
        const newChords = [...chords];
        newChords[index] = value;
        setChords(newChords);
    };

    const triggerAnalysis = useCallback(() => {
        if (debouncedAnalysis.current) clearTimeout(debouncedAnalysis.current);
        debouncedAnalysis.current = setTimeout(async () => {
            const activeChords = chords.filter(c => c.trim() !== '');
            if (activeChords.length === 0) {
                setAnalysis(null);
                return;
            }
            setIsLoading(true);
            setError(null);
            try {
                const result = await analyzeProgressionWithGemini(chords);
                if (result && Array.isArray(result.progressionAnalysis) && result.progressionAnalysis.length > 0) {
                    setAnalysis(result);
                    const defaultNotes = {};
                    result.progressionAnalysis.forEach((chordAnalysis, index) => {
                        const rootNote = chordAnalysis?.allTargetOptions?.find(opt => opt.interval === 'R');
                        if(rootNote) defaultNotes[index] = rootNote;
                    });
                    setSelectedNotes(defaultNotes);
                } else {
                    setError("L'analyse IA a retourné une réponse invalide ou vide.");
                    setAnalysis(null);
                    console.error("Invalid or empty analysis from Gemini:", result);
                }
            } catch (e) {
                setError(e.message || "Failed to analyze progression.");
                console.error(e);
            } finally {
                setIsLoading(false);
            }
        }, 1000);
    }, [chords]);
    
    useEffect(() => {
        triggerAnalysis();
    }, [chords, triggerAnalysis]);

    useEffect(() => {
        synths.bass = new MonoSynth().toDestination();
        synths.bass.set({ oscillator: { type: 'fatsawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 } });
        synths.chord = new PolySynth(Synth).toDestination();
        synths.chord.set({ oscillator: { type: "fatsawtooth", count: 3, spread: 30 }, envelope: { attack: 0.4, decay: 0.1, sustain: 0.8, release: 1.5 } });
        synths.metro = new MembraneSynth().toDestination();
        synths.metro.set({ pitchDecay: 0.01, octaves: 4, oscillator: { type: 'square' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 } });
        return () => {
            Object.values(synths).forEach(synth => synth?.dispose());
            Transport.cancel(0);
        };
    }, []);

    useEffect(() => {
        Transport.bpm.value = tempo;
        if(synths.metro) synths.metro.volume.value = volumes.metro;
        if(synths.bass) synths.bass.volume.value = volumes.bass;
        if(synths.chord) synths.chord.volume.value = volumes.chord;
    }, [tempo, volumes, synths]);

    useEffect(() => {
        let timer;
        if (playerState === PlayerState.Playing || isYoutubePlaying) {
            timer = setInterval(() => {
                updateGamificationData(prev => {
                    const newXp = prev.xp + GAMIFICATION_XP_PER_SECOND;
                    const newLevel = prev.level + Math.floor(newXp / GAMIFICATION_XP_PER_LEVEL);
                    return {
                        ...prev,
                        timePlayed: prev.timePlayed + 1,
                        xp: newXp % GAMIFICATION_XP_PER_LEVEL,
                        level: newLevel,
                    };
                });
            }, 1000);
        }
        return () => clearInterval(timer);
    }, [playerState, isYoutubePlaying, updateGamificationData]);

    const analysisByCell = useMemo(() => {
        if (!analysis || !Array.isArray(analysis.progressionAnalysis)) return [];
        const result = Array(TOTAL_CELLS).fill(undefined);
        let analysisIndex = 0;
        chords.forEach((chord, cellIndex) => {
            if (chord.trim() !== '' && analysis.progressionAnalysis[analysisIndex]) {
                result[cellIndex] = analysis.progressionAnalysis[analysisIndex];
                analysisIndex++;
            }
        });
        return result;
    }, [analysis, chords]);

    const cellToAnalysisIndexMap = useMemo(() => {
        if (!analysis || !Array.isArray(analysis.progressionAnalysis)) return {};
        const map = {};
        let analysisIndex = 0;
        chords.forEach((chord, cellIndex) => {
            if (chord.trim() !== '') {
                if (analysis.progressionAnalysis[analysisIndex]) {
                    map[cellIndex] = analysisIndex;
                    analysisIndex++;
                }
            }
        });
        return map;
    }, [analysis, chords]);

    const stopPlayback = useCallback(() => {
        Transport.stop();
        Transport.cancel(0);
        transportPart.current?.dispose();
        countdownPart.current?.dispose();
        synths.bass?.triggerRelease(context.currentTime);
        synths.chord?.releaseAll(context.currentTime);
        setPlayerState(PlayerState.Stopped);
        setCurrentBeat(-1);
    }, [synths]);

    const startPlayback = useCallback(() => {
        const activeChords = chords.map((c, i) => ({ chord: c, index: i })).filter(item => item.chord.trim() !== '');
        if (activeChords.length === 0) return;
        const lastChordCellIndex = Math.max(...activeChords.map(c => c.index));
        const totalBeatsInProgression = (lastChordCellIndex + 1) * 2;
        const loopEndMeasures = Math.ceil(totalBeatsInProgression / 4);
        if (loopEndMeasures === 0) return;
        const events = [];
        let chordMap = new Map();
        chords.forEach((c, i) => { if (c.trim()) chordMap.set(i, c.trim())});
        for(let i=0; i<loopEndMeasures * 4; i++) {
            const time = `0:${i}`;
            const cellIndex = Math.floor(i / 2);
            events.push({ time, beat: i, type: 'highlight' });
            events.push({ time, note: i % 4 === 0 ? 'C5' : 'C4', type: 'metro' });
            if(i % 2 === 0 && chordMap.has(cellIndex)) {
                const chordName = chordMap.get(cellIndex);
                const rootNote = chordName.match(/^[A-G][#b]?/)?.[0];
                const chordAnalysis = analysisByCell[cellIndex];
                if(rootNote) {
                    let nextChangeBeat = totalBeatsInProgression;
                    for(let j=cellIndex+1; j <= lastChordCellIndex; j++) {
                        if(chordMap.has(j)) { nextChangeBeat = j * 2; break; }
                    }
                    const durationBeats = nextChangeBeat - i;
                    const duration = `0:${durationBeats}`;
                    events.push({ time, note: rootNote + '2', duration, type: 'bass' });
                    if (chordAnalysis?.notes?.length > 0) {
                        events.push({ time, notes: chordAnalysis.notes.map(n => n+'4'), duration, type: 'chord' });
                    }
                }
            }
        }
        transportPart.current = new Part((time, value) => {
            if (value.type === 'highlight') Draw.schedule(() => setCurrentBeat(value.beat), time);
            else if (value.type === 'metro') synths.metro?.triggerAttackRelease(value.note, '16n', time);
            else if (value.type === 'bass') synths.bass?.triggerAttackRelease(value.note, value.duration, time);
            else if (value.type === 'chord') synths.chord?.triggerAttackRelease(value.notes, value.duration, time);
        }, events).start('1m');
        transportPart.current.loop = true;
        transportPart.current.loopEnd = `${loopEndMeasures}m`;
        countdownPart.current = new Part((time, value) => {
             synths.metro?.triggerAttackRelease('C5', '8n', time);
             Draw.schedule(() => setCurrentBeat(value.beat), time);
        }, [{time: '0:0', beat: -4}, {time: '0:1', beat: -3}, {time: '0:2', beat: -2}, {time: '0:3', beat: -1}]).start(0);
        Transport.loop = true;
        Transport.loopStart = '1m';
        Transport.loopEnd = `${loopEndMeasures + 1}m`;
        Transport.scheduleOnce(() => setPlayerState(PlayerState.Playing), '1m');
        Transport.start();
        setPlayerState(PlayerState.CountingDown);
    }, [chords, synths, analysisByCell]);

    const handlePlayStop = async () => {
        if (context.state !== 'running') await start();
        if (playerState !== PlayerState.Stopped) stopPlayback();
        else startPlayback();
    };

    const getHighlightedNotes = useCallback(() => {
        if (!analysis?.progressionAnalysis?.length) return [];
        const firstAnalysisIndex = cellToAnalysisIndexMap[Object.keys(cellToAnalysisIndexMap)[0]];
        if (firstAnalysisIndex === undefined) return [];

        if (playerState === PlayerState.Stopped) {
            const firstAnalysis = analysis.progressionAnalysis[firstAnalysisIndex];
            const selectedNote = selectedNotes[firstAnalysisIndex] ?? firstAnalysis?.allTargetOptions?.find(o => o.interval === 'R');
            return selectedNote ? [{ note: selectedNote.note, color: '#a855f7', isBlinking: false }] : [];
        }
        if (playerState === PlayerState.CountingDown) {
            const firstAnalysis = analysis.progressionAnalysis[firstAnalysisIndex];
            const selectedNote = selectedNotes[firstAnalysisIndex] ?? firstAnalysis?.allTargetOptions?.find(o => o.interval === 'R');
            return selectedNote ? [{ note: selectedNote.note, color: '#facc15', isBlinking: false }] : [];
        }
        const currentCellIndex = Math.floor(currentBeat / 2);
        let currentAnalysisIndex = -1;
        for (let i = currentCellIndex; i >= 0; i--) {
            if (cellToAnalysisIndexMap[i] !== undefined) { currentAnalysisIndex = cellToAnalysisIndexMap[i]; break; }
        }
        if (currentAnalysisIndex === -1) return [];
        let nextAnalysisIndex = -1;
        for (let i = currentCellIndex + 1; i < TOTAL_CELLS; i++) {
             if (cellToAnalysisIndexMap[i] !== undefined) { nextAnalysisIndex = cellToAnalysisIndexMap[i]; break; }
        }
        if (nextAnalysisIndex === -1) { 
            const firstCellWithChord = Object.keys(cellToAnalysisIndexMap).map(Number).sort((a, b) => a-b)[0];
            nextAnalysisIndex = cellToAnalysisIndexMap[firstCellWithChord];
        }
        if (nextAnalysisIndex === undefined) return [];
        const currentAnalysis = analysis.progressionAnalysis[currentAnalysisIndex];
        const nextAnalysis = analysis.progressionAnalysis[nextAnalysisIndex];
        if (!currentAnalysis || !nextAnalysis) return [];
        const notes = [];
        const currentSelectedNote = selectedNotes[currentAnalysisIndex] ?? currentAnalysis.allTargetOptions?.find(o => o.interval === 'R');
        if (currentSelectedNote) notes.push({ note: currentSelectedNote.note, color: '#a855f7', isBlinking: true });
        const nextSelectedNote = selectedNotes[nextAnalysisIndex] ?? nextAnalysis.allTargetOptions?.find(o => o.interval === 'R');
        if (nextSelectedNote && nextSelectedNote.note !== currentSelectedNote?.note) {
             notes.push({ note: nextSelectedNote.note, color: '#facc15', isBlinking: false });
        }
        return notes;
    }, [analysis, playerState, currentBeat, selectedNotes, cellToAnalysisIndexMap]);

    const handleSelectNote = (analysisIndex, note) => {
        setSelectedNotes(prev => ({ ...prev, [analysisIndex]: note }));
    };
    
    const handleYoutubePlaybackChange = (isPlaying) => setIsYoutubePlaying(isPlaying);
    
    const handleTrackLoaded = (track) => {
        setCurrentTrack(track);
        updateGamificationData(prev => {
            const existingTracks = prev.recentTracks || [];
            const filteredTracks = existingTracks.filter(t => t.videoId !== track.videoId);
            const newTracks = [track, ...filteredTracks].slice(0, 5);
            return { ...prev, recentTracks: newTracks };
        });
    };

    const handleAnalyzeVideo = async () => {
        if (!currentTrack || !isAiAvailable) {
             if(!isAiAvailable) setError("Fonctionnalité IA non disponible : Clé API manquante.");
            return;
        }
        setIsAnalyzingVideo(true);
        setError(null);
        try {
            const extractedChords = await extractChordsFromVideoWithGemini(currentTrack.title);
            if (extractedChords && extractedChords.length > 0) {
                const newChords = Array(TOTAL_CELLS).fill('');
                let gridIndex = 0;
                for (const chord of extractedChords) {
                    if (gridIndex < TOTAL_CELLS) {
                        newChords[gridIndex] = chord;
                        gridIndex += 2;
                    }
                }
                setChords(newChords);
            } else {
                setError("L'IA n'a pas pu trouver d'accords dans le titre de la vidéo.");
            }
        } catch (e) {
            setError(e.message || "L'extraction des accords a échoué.");
            console.error(e);
        } finally {
            setIsAnalyzingVideo(false);
        }
    };

    const loadPreset = () => {
        const preset = PRESET_PROGRESSIONS[Math.floor(Math.random() * PRESET_PROGRESSIONS.length)];
        const newChords = Array(TOTAL_CELLS).fill('');
        preset.chords.forEach((c, i) => newChords[i] = c);
        setChords(newChords);
    };

    const clearGrid = () => {
        setChords(Array(TOTAL_CELLS).fill(''));
        setAnalysis(null);
    };
    
    const handleLogout = useCallback(async () => {
        try {
            if (currentUser) await saveUserData();
            await signOut(auth);
        } catch (error) {
            console.error("Logout Error:", error);
        }
    }, [currentUser, saveUserData]);
    
    const getGreeting = () => {
        const hour = new Date().getHours();
        return hour < 18 ? 'Bonjour' : 'Bonsoir';
    };

    return (
        <>
            <div className="min-h-screen p-2 sm:p-4 pb-40">
                <div className="w-full max-w-7xl mx-auto flex flex-col gap-4">
                    {!isAiAvailable && (
                        <div className="bg-yellow-500/10 border border-yellow-500/30 text-yellow-200 text-sm rounded-lg p-3 text-center">
                           <span className="font-bold">Mode Démo :</span> L'analyse IA est simulée (la clé API est manquante dans l'environnement).
                        </div>
                    )}
                    <header className="flex justify-between items-center py-4">
                        <div className="text-left">
                            <h1 className="text-3xl md:text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-blue-500 mb-1">
                                🎸 GIA Navigator
                            </h1>
                            <p className="text-md text-gray-400">Votre plan d'action visuel pour l'improvisation.</p>
                        </div>
                         <div className="flex items-center gap-4">
                            {currentUser ? (
                                <>
                                    <div className="flex items-center gap-2">
                                        <SaveStatusIndicator status={saveStatus} />
                                        <div className="text-right">
                                            {gamificationData.firstName ? (
                                                <p className="font-semibold text-gray-100">{getGreeting()}, {gamificationData.firstName}!</p>
                                            ) : (
                                                <p className="text-sm text-gray-300 truncate">{currentUser.email}</p>
                                            )}
                                            <button onClick={handleLogout} className="text-xs text-red-400 hover:underline">Déconnexion</button>
                                        </div>
                                    </div>
                                    <UserIcon className="w-8 h-8 text-gray-400"/>
                                </>
                            ) : (
                                <button onClick={() => setIsAuthModalOpen(true)} className="flex items-center gap-2 bg-gray-800 hover:bg-gray-700 text-gray-300 font-semibold py-2 px-4 rounded-lg transition">
                                    <UserIcon className="w-5 h-5"/>
                                    <span>Connexion / Inscription</span>
                                </button>
                            )}
                        </div>
                    </header>

                    <main className="flex flex-col gap-4">
                        <section className="p-4 bg-gray-900/50 rounded-xl border border-gray-800">
                            <h2 className="text-lg font-bold text-white mb-4">1. Backing Track (Optionnel)</h2>
                            <YoutubePlayer 
                                onPlaybackChange={handleYoutubePlaybackChange}
                                onTrackLoaded={handleTrackLoaded}
                                recentTracks={gamificationData.recentTracks}
                                onAnalyzeVideo={handleAnalyzeVideo}
                                isAnalyzingVideo={isAnalyzingVideo}
                                isAiAvailable={isAiAvailable}
                            />
                        </section>
                    
                        <section className="p-4 bg-gray-900/50 rounded-xl border border-gray-800">
                             <div className="flex justify-between items-center mb-4">
                                <h2 className="text-lg font-bold text-white">2. Entrez votre grille (1 case = 2 temps)</h2>
                                <div className="flex gap-2">
                                    <button onClick={loadPreset} className="text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold py-1.5 px-3 rounded-lg transition">🎲 Aléatoire</button>
                                    <button onClick={clearGrid} className="text-xs bg-red-800/50 hover:bg-red-700 text-white font-semibold py-1.5 px-3 rounded-lg transition">🗑️ Vider</button>
                                </div>
                            </div>

                            <div className="grid grid-cols-8 gap-1 mb-4">
                                {chords.map((chord, i) => {
                                    const currentCell = Math.floor(currentBeat / 2);
                                    const isActive = playerState === PlayerState.Playing && i === currentCell;
                                    return (
                                        <input
                                            key={i}
                                            type="text"
                                            value={chord}
                                            onChange={(e) => handleChordChange(i, e.target.value)}
                                            className={`w-full p-2 text-center font-bold text-white bg-gray-800 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all duration-150 ${
                                                isActive ? 'ring-2 ring-blue-400 shadow-lg shadow-blue-400/20' : ''
                                            }`}
                                        />
                                    );
                                })}
                            </div>

                            <GuitarNeck highlightedNotes={getHighlightedNotes()} scaleNotes={analysis?.notesGamme} />
                            
                            <div className="mt-4 flex flex-col md:flex-row items-center justify-between gap-4 p-3 bg-gray-900 rounded-lg">
                                <button onClick={handlePlayStop} disabled={playerState === PlayerState.CountingDown} className="w-full md:w-auto flex items-center justify-center gap-3 px-6 py-3 font-bold text-white bg-emerald-600 rounded-lg hover:bg-emerald-500 transition-all duration-200 disabled:bg-gray-500 disabled:cursor-wait">
                                    {playerState === PlayerState.Stopped && <PlayIcon className="w-6 h-6" />}
                                    {playerState !== PlayerState.Stopped && <StopIcon className="w-6 h-6" />}
                                    <span>{
                                        playerState === PlayerState.Stopped ? 'Play' :
                                        playerState === PlayerState.CountingDown ? `Décompte ${4 - (currentBeat * -1 - 1)}` :
                                        'Stop'
                                    }</span>
                                </button>
                                <div className="w-full md:w-auto flex items-center gap-3">
                                    <label htmlFor="tempo" className="font-semibold text-gray-300">Tempo:</label>
                                    <input type="range" id="tempo" min="40" max="200" value={tempo} onChange={e => setTempo(Number(e.target.value))} className="w-full"/>
                                    <span className="w-16 text-center font-bold">{tempo} bpm</span>
                                </div>
                            </div>
                        </section>

                        <section className="p-4 bg-gray-900/50 rounded-xl border border-gray-800">
                             <h2 className="text-lg font-bold text-white mb-1">3. Votre Plan d'Action GIA</h2>
                             {isLoading ? (
                                <div className="flex items-center justify-center h-48 gap-3 text-gray-400">
                                    <LoadingSpinner className="w-8 h-8"/>
                                    <span>Analyse par IA en cours...</span>
                                </div>
                             ) : error ? (
                                <div className="text-red-400 text-center h-48 flex items-center justify-center">{error}</div>
                             ) : analysis ? (
                                <>
                                    <div className="flex items-baseline gap-4 mb-4">
                                        <p className="font-semibold text-blue-300">Tonalité: {analysis.tonalite}</p>
                                        <div className="flex gap-2 items-center text-sm text-gray-300 flex-wrap">
                                            {analysis.notesGamme && analysis.notesGamme.map(n => <span key={n} className="font-mono bg-gray-700 px-1.5 py-0.5 rounded-md">{n}</span>)}
                                        </div>
                                    </div>
                                    <div className="flex flex-wrap -m-1">
                                    {analysis.progressionAnalysis && analysis.progressionAnalysis.map((item, index) => (
                                        item && <AnalysisCard 
                                            key={index}
                                            analysis={item}
                                            analysisIndex={index}
                                            onSelectNote={(note) => handleSelectNote(index, note)}
                                            selectedNote={selectedNotes[index]}
                                        />
                                    ))}
                                    </div>
                                </>
                             ) : (
                                 <div className="text-gray-500 text-center h-48 flex items-center justify-center">Entrez une grille d'accords pour commencer l'analyse.</div>
                             )}
                        </section>
                    </main>
                </div>
            </div>
            <GamificationDashboard data={gamificationData} />
            <AuthModal isOpen={isAuthModalOpen} onClose={() => setIsAuthModalOpen(false)} initialGamificationData={gamificationDataRef.current} />
        </>
    );
}

// === RENDER LOGIC ===
// Final step: render the App component into the DOM.
const rootElement = document.getElementById('root');
if (!rootElement) {
    throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
    <React.StrictMode>
        <App />
    </React.StrictMode>
);

    </script>
  </body>
</html>